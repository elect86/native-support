/*
 * This source file was generated by the Gradle 'init' task
 */
package org.nativeSupport

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.attributes.Category
import org.gradle.api.attributes.Usage

/**
 * A simple 'hello world' plugin.
 */
class NativeSupportPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Register a task
        //        project.tasks.register("greeting") { task ->
        //            task.doLast {
        //                println("Hello from plugin 'org.example.greeting'")
        //            }
        //        }
//        project.configurations.forEach {
//            //                println("[$this] $attributes")
////            if (it.name.endsWith("CompileClasspath") || it.name.endsWith("RuntimeClasspath")) {
////                println("[$it] ${it.attributes}")
//                // we want to find configurations such as, but we want to filter out the ones like the last one
//                // desktopCompileClasspath
//                // desktopRuntimeClasspath
//                // desktopTestCompileClasspath
//                // desktopTestRuntimeClasspath
//                // metadataCompileClasspath
//                //                val usage = attributes.getAttribute(Usage.USAGE_ATTRIBUTE)?.name
//                //                if (usage == null || usage == Usage.JAVA_API || usage == Usage.JAVA_RUNTIME)
////                it.attributes {
////                    // select a platform, will fail to compose a runtime classpath if none is selected
////                    os = OS.current // or MACOS or LINUX
////                    arch = Arch.current   // or x86-64 or arm32 or arm64
////                }
////            }
//        }
        project.afterEvaluate {
            configurations.configureEach {
                if (name.endsWith("CompileClasspath") || name.endsWith("RuntimeClasspath")) {
//                    println(this@configureEach)
//                    println(attributes)
                    attributes {
                        val category = category?.name
                        val usage = usage?.name
                        // we want to find configurations such as, but we want to filter out the ones like the last one
                        // configuration ':composeApp:desktopCompileClasspath'
                        // {org.gradle.category=library, org.gradle.jvm.environment=standard-jvm, org.gradle.usage=java-api, org.jetbrains.kotlin.platform.type=jvm}
                        // configuration ':composeApp:desktopRuntimeClasspath'
                        // {org.gradle.category=library, org.gradle.jvm.environment=standard-jvm, org.gradle.usage=java-runtime, org.jetbrains.kotlin.platform.type=jvm}
                        // configuration ':composeApp:desktopTestCompileClasspath'
                        // {org.gradle.category=library, org.gradle.jvm.environment=standard-jvm, org.gradle.usage=java-api, org.jetbrains.kotlin.platform.type=jvm}
                        // configuration ':composeApp:desktopTestRuntimeClasspath'
                        // {org.gradle.category=library, org.gradle.jvm.environment=standard-jvm, org.gradle.usage=java-runtime, org.jetbrains.kotlin.platform.type=jvm}
                        // configuration ':composeApp:metadataCompileClasspath'
                        // {org.gradle.category=library, org.gradle.jvm.environment=non-jvm, org.gradle.usage=kotlin-metadata, org.jetbrains.kotlin.platform.type=common}
                        if (category == Category.LIBRARY && (usage == Usage.JAVA_API || usage == Usage.JAVA_RUNTIME)) {
                            // let's try only the `runtime` usage since this should be included the `api` as well
                            //                        if (category == Category.LIBRARY && usage == Usage.JAVA_RUNTIME) {
                            // select a platform, will fail to compose a runtime classpath if none is selected
                            os = OS.current // or MACOS or LINUX
                            arch = Arch.current   // or x86-64 or arm32 or arm64

//                            incoming.afterResolve {
//                                for (artifact in resolvedConfiguration.resolvedArtifacts)
//                                    if (artifact.classifier == "natives-$os-$arch")
//                                        println(xdg.cacheHome)
                                    // we just want to extract once, ie: if there is no other file other than (the) `.jar` (itself)
//                                        if (artifact.file.parentFile.listFiles()!!.none { it.extension != "jar" })
//                                            project.copy {
//                                                from(zipTree(artifact.file))
//                                                into(artifact.file.parent)
//                                            }
//                            }
                        }
                    }
                }
            }
        }
    }
}
